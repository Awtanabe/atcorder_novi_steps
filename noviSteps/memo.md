### 悩み始めたら
### 問題の解き方の考え方 => シンプルになる

- 1.全探索 =>省略したり、効率化で記録したりがレベルを上げていく処理

---

## 1. 基本は「全探索」

* まずは「**作れる候補を全部作ってみる**」という考え方。
* 特に「3と5と7だけでできる数字」みたいに **選択肢が少ない問題** では、全探索で十分解けます。
* 今回も桁数が最大 9 桁、選択肢が 3 通りなので
  → 探索数は **3^9 = 約2万弱**
  → コンピュータなら一瞬。

---

## 2. 効率化の方向性

全探索で間に合わないときは「余分な探索を減らす工夫」を入れます。たとえば：

### (1) 枝刈り

* 今回の `cur > N` で return するのも枝刈り。
* どうせ条件を満たさない枝は早めに切り捨てる。

### (2) 判定の高速化

* 文字列変換して「3,5,7が含まれるか？」を見る代わりに、ビットマスクで「この数は 3 を使った / 5 を使った / 7 を使った」と記録しておけば、毎回文字列にしなくてもよい。

### (3) 重複計算の回避

* 同じ部分計算を繰り返さないように「メモ化」する。
  → これは典型的な **DP（動的計画法）**。

---

## 3. 考え方の流れ

1. **まず全探索を考える**

   * 問題サイズが小さければ、それで解決。
   * コードもわかりやすい。

2. **計算量が大きそうなら工夫する**

   * 「最大で何回ループするか」を概算。
   * 「この条件の時はもう探索不要だ」と枝刈り。
   * 「同じ計算を繰り返してないか？」とメモ化/DP。

---

## 4. まとめ

* 今回みたいに「選択肢が少ない・桁数が少ない」問題 → **全探索でOK**。
* 全探索が間に合わないときは → **条件式やデータ構造を工夫して探索を削る**。
* プログラミングコンテストや実務でもこの流れはよく出てきます。


### 解説AC

- [x] シミュレーション 1 First Query Problem
  - 入力 Scannerの勉強で進まなかった
- [x] シミュレーション 2 => 二分探索なので後でやる
- [x] 全探索 ① typo
- [x] 全探索 ②
- [x] 多重 for文 3
- [x] 多重 for文 4
  - mod 除数でインデックスをぐるぐる回る
- [x] 多重 for文 5
  - atcorder => max min 閾値はテストをする癖をみにつけないと実装が漏れる ⭐️実務にも役立つ
- [x] 二次元グリット 2
- [x] シミュレーショ3
- [x] スタック
  - スライスで表現できたはず
	  - インデックス指定じゃなくてappendで追加できるみたい
  - make([]int, 0, N)
    - 長さを0にする事でからの配列を作成できる
- [x] キュー
  - キューもスタックと使うものは同じ
- [x] 再帰関数
- [x] スタック DP高速化
  - 動的計画法 (Dynamic Programming)
    - 大きな問題を小さな部分問題に分割して解く
	- 結果的に配列にメモ化して対応する(累積和など)
- [x] 貪欲法
  - 効率良い選択をすること
	  - 大きい順に並べた方が良いとか
- [] 再帰全探索
- [x] Frequency

### メモ

Atoiなどの処理はほぼ無視して良いらしい O(1)と考えても差し支えないらしい

### スタック

- appendで追加できる
- 取り除く
  - data[1:] 

```
package main

import "fmt"

func main() {
	data := []int{1}
	fmt.Println("Hello, 世界", data)
	data = append(data, 2, 3, 4)
	fmt.Println("Hello, 世界", data)
	data = data[1:]
	fmt.Println("Hello, 世界", data)
}

Hello, 世界 [1]
Hello, 世界 [1 2 3 4]
Hello, 世界 [2 3 4]
```

### Aggregate

- 集約 解き方
  - バケットとは
	  - スライスのこと
		  - var buckect [10]int
  - バケットに状態を記録してカウントs


### 2025/08/30

#### 解説 acでやったものを見ていく

- test ディレクトリを作業場にする

##### 全探索 1 typo
- 文字の入れ替えをどおするか？で迷った
  - []runeに文字列を変換
  - s[i], s[i+1] = s[i+1], s[i]でスワップ
- ポイント
　- 横並びのスワップで良いのはやりやすかった
    - 横並びじゃなかったとしても、一致であればsortしたりすれば解決するだろうな


##### シミュレーション 2 savings ⭐️ => 二分探索なので後で

- 貯金箱に i円を入れていく
  - 1 <= i
- N円以上入っているのは何日め？

- ポイント
  - 普通に計算すると計算量が多いので、下記の2つしかアプローチがない
    - 数列の数式による計算量 0(1)
    - 二分探索
- 問題
  - 普通にやると オーバーフローとか速度的に問題ありっぽい
  s

##### シミュレーション First Query Problem

- 問題
  - 長さN個のN個の整数が渡される
  - Q個のクエリが渡される
    - クエリ
      - 1と2がある
        - 1は k x
          - インデックス kの数字を xに変更する
        - 2は k
          - インデックス kの値を出力する

- 振り返り
  - 問題の理解に手こずった
  - Scanを Scannerに変更するのも時間がかかった
  - 文字列から数字への変更も

```go
package main

import (
	"bufio"
	"fmt"
	"os"
	"strconv"
	"strings"
)

func main() {
	var N, Q int

	fmt.Scan(&N)

	data := make([]int, N)
	for i := 0; i < N; i++ {
		fmt.Scan(&data[i])
	}

	fmt.Scan(&Q)
	scanner := bufio.NewScanner(os.Stdin)

	for i := 0; i < Q; i++ {
		if scanner.Scan() {
			text := scanner.Text()
			strs := strings.Split(text, " ")

			if strs[0] == "1" {
				k, _ := strconv.Atoi(strs[1])
				x, _ := strconv.Atoi(strs[2])
				data[k-1] = x
			}

			if strs[0] == "2" {
				k, _ := strconv.Atoi(strs[1])
				fmt.Println(data[k-1])
			}
		}
		if err := scanner.Err(); err != nil {
			fmt.Fprintln(os.Stderr, "読み取りエラー:", err)
		}

	}

}
```

##### 集計(バケット・連想配列の利用) Frequency
  - 文字列 を取得
  - アルファベットは 26個あるので、intスライスを26個確保
    - 
  - 文字の扱いは runeで rune - 'a'で差分を確保 && byte('a' + 差分)で文字列を
  - ポイント
    - カウント方法
      - バケットのインデックスがそのままアルファベットの位置になるs
    - max と idxの変数2つ使わないといけない
      - うまくいなかったのは maxを追加してしまったのでアスキーコードの範囲外で string(re)で出力しても何も表示されなかった(数字99以降とかだったはず)

```go
import "fmt"

func main() {
	diff := 'b' - 'a'
	res := 'a' + diff
	fmt.Println("Hello, 世界", string(res))
}

```

